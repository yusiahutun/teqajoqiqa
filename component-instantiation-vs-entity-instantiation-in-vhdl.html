<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Component Instantiation vs Entity Instantiation in VHDL - ZingX</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content="I have experience with Verilog/SystemVerilog but I am new to VHDL and I am trying to figure out when I should use component instantiation or entity instantiation. By component instantiation I mean the legacy way of declaring components of an entity before instantiating them. On the other hand, entity instantiation, which has been introduced with"><meta name=robots content="index,follow,noarchive"><meta property="og:title" content="Component Instantiation vs Entity Instantiation in VHDL"><meta property="og:description" content="I have experience with Verilog/SystemVerilog but I am new to VHDL and I am trying to figure out when I should use component instantiation or entity instantiation. By component instantiation I mean the legacy way of declaring components of an entity before instantiating them. On the other hand, entity instantiation, which has been introduced with"><meta property="og:type" content="article"><meta property="og:url" content="/component-instantiation-vs-entity-instantiation-in-vhdl.html"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-04-30T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-30T00:00:00+00:00"><meta itemprop=name content="Component Instantiation vs Entity Instantiation in VHDL"><meta itemprop=description content="I have experience with Verilog/SystemVerilog but I am new to VHDL and I am trying to figure out when I should use component instantiation or entity instantiation. By component instantiation I mean the legacy way of declaring components of an entity before instantiating them. On the other hand, entity instantiation, which has been introduced with"><meta itemprop=datePublished content="2024-04-30T00:00:00+00:00"><meta itemprop=dateModified content="2024-04-30T00:00:00+00:00"><meta itemprop=wordCount content="948"><meta itemprop=keywords content><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=https://assets.cdnweb.info/hugo/mainroad/css/style.css><link rel="shortcut icon" href=./favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=./index.html title=ZingX rel=home><div class="logo__item logo__text"><div class=logo__title>ZingX</div></div></a></div><div class=divider></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Component Instantiation vs Entity Instantiation in VHDL</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2024-04-30T00:00:00Z>April 30, 2024</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=./categories/blog/ rel=category>blog</a></span></div></div></header><div class="content post__content clearfix"><p>I have experience with Verilog/SystemVerilog but I am new to VHDL and I am trying to figure out when I should use component instantiation or entity instantiation. By component instantiation I mean the legacy way of declaring components of an entity before instantiating them. On the other hand, entity instantiation, which has been introduced with <a href=# rel=noreferrer>VHDL-93</a>, allows you to declare an entity directly without specifying the component. <a href=# rel=noreferrer>Related Article</a></p><p>It seems to me that Entity Instantiation is always preferable unless you don't have an architecture implemented yet and you just want to define a black box.</p><p>This is a <a href=#>Related Question</a> that I've found but it does fully address my doubts. Since it is possible to define both the generic map and the architecture for any entity:</p><pre><code>entity work.MyEntity_E(ARCH) generic map( ...) port map( ... ); </code></pre><p>what is the additional flexibility of doing component instantiation? What would be the simplest example showing <strong>something that can not be done with entity instantiation but can be done with component instantiation</strong>?</p><span class=d-none itemprop=commentCount>3</span><h2 class=mb0 data-answercount=3>3 Answers</h2><p>I like to think of a component as being like an IC socket. You can take that analogy further by likening compilation (analysis) to assembling the PCB and likening elaboration to putting the chips in the sockets. If you use IC sockets, you can assemble the PCB even if you haven't ordered the chips yet; you can defer putting the chips in the socket till later. Likewise if you use components: you can compile the design if even if the entities and architectures corresponding to the components don't yet exist; you can defer binding till later, till elaboration.</p><p>So, why might that be? Why might they not yet exist?</p><p>i) It's a big project. Not every one has finished their block yet. But you can still easily compile the top-level and run simulations on either bits of the design. You could do this by commenting-out/editing, but using components makes it easier.</p><p>ii) You've generated some IP automatically. This has given you a behavioural model for simulation, but no synthesisable model - the idea is that you combine some auto-generated physical view of the IP later in the flow. This is OK for simulation, but how can you compile your design for synthesis if there's a bit missing - your generated IP?</p><p>iii) You're doing recursive instantiation: you're instantiating one block inside itself. With direct instantiation, you've got an unbreakable chicken-and-egg situation (aka a circular dependency); with direct instantiation, you cannot instantiate something that has yet to be compiled, yet you cannot compile it, because the instantiated entity has not yet been compiled. Component instantiation can break this circular dependency.</p><p>iv) Component instantiation also enables you to instantiate different entities in the same place in your design (under the control of a configuration). @user1155120 gives an example of that above: using component instantiation (and a configuration) enables you to create identical blocks with differing sub-blocks.</p><p>Here's an example comparing the two on <a href=# rel=noreferrer>EDA Playground - https://www.edaplayground.com/x/2QrS</a>.</p><span class=d-none itemprop=commentCount>3</span><p>One of the things you can accomplish with configuration (which depends on component instantiation) is the use of virtual components.</p><p>You can write a VHDL description that depends on some idealized entity (named x here) and map it to different component with different port signal names:</p><pre><code>entity a is port ( in1: in bit; in2: in bit; out1: out bit ); end entity; architecture fum of a is begin out1 &lt;= in1 xor in2; end architecture; entity b is end entity; architecture foo of b is component x is port ( a: in bit; b: in bit; c: out bit ); end component; signal a, b, c: bit; begin TARG: x port map ( a =&gt; a, b =&gt; b, c =&gt; c ); STIMULI: process begin wait for 2 ns; a &lt;= '1'; wait for 2 ns; b &lt;= '1'; wait for 2 ns; a &lt;= '0'; wait for 2 ns; b &lt;= '0'; wait for 2 ns; a &lt;= '1'; wait for 2 ns; wait; end process; end architecture; configuration fum of b is for foo for TARG: x use entity work.a port map ( in1 =&gt; a, in2 =&gt; b, out1 =&gt; c ); end for; end for; end configuration fum; </code></pre><p>elaborating and simulating the configuration gives:</p><p><a href=# rel="nofollow noreferrer"><img src=https://cdn.statically.io/img/i.stack.imgur.com/9Io1O.png alt=fum.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>When looking a TARG's port signals.</p><p>This ability was intended to be used to map primitives from different vendor libraries to a standard component declaration.</p><p>The perceived complexity involved in configuration was countered with portability libraries such as LPM (Library of Parameterized Modules) which add a different axis of complexity via he use of attributes and generics while standardizing interface names and reducing the number of library primitives.</p><p>Behavioral synthesis has advance to the point both methods of structural design specification have fallen the way side.</p><p>FPGA vendor support for explicit configuration declarations has also historically lagged. You could note that IEEE Std 1076.6-2004 (RTL Synthesis, now withdrawn) required support for configuration declarations and implicit configuration provides default binding indications during elaboration.</p><span class=d-none itemprop=commentCount>1</span><p>VHDL was originally a hardware documentation language. Not a simulation nor a synthesising one.</p><p>I agree that component instantiation is painfully verbose, but it's more readable in case the entity is not declared on the same source file.</p><p>Also, on really big projects. It allows to separate the compilation of each entity. So changing one entity doesn't mean recompiling the whole project.</p><p>And allows to easily swap with behavioral archs for simulation. Ie: a DRAM will just be a bunch of ports of your fpga. Or you may download a dram model and verify that your code is working as expected. You don't need to go back and change the instantiation each time you simulate something.</p><span class=d-none itemprop=commentCount>6</span><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmirpJawrLvVnqmfpJ%2Bse6S7zGiorp2jqbawutJoam9qYm6Ad4SOnKamqJ%2Bjsq%2FAjKKlrKyRo8GqrdOipqdlpqh6prrToquyZZmjwLWtza2gmqyZpLtutc1mraGcnA%3D%3D</p></div></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=./former-browns-quarterback-bernie-kosar-busted-drunk-driving-speeding-html.html rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>Former Browns quarterback Bernie Kosar BUSTED for DRUNK DRIVING, speeding</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=./chinese-traitors-wearing-son-heung-min-shirts-mobbed-angry-home-fans-during-loss-south-korea.html rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>Chinese traitors wearing Son Heung-min shirts mobbed by angry home fans during loss to South K</p></a></div></nav></div><aside class=sidebar><div class="widget-recent widget"><h4 class=widget__title>Recent Posts</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=./brian-hartline-and-lindsay-smith-spouse.html>Brian Hartline and Lindsay Smith (spouse)</a></li><li class=widget__item><a class=widget__link href=./eden-munoz-announces-consejos-gratis-us-tour.html>Eden Muoz Announces Consejos Gratis US Tour</a></li><li class=widget__item><a class=widget__link href=./beijing-trying-create-new-status-quo-sending-balloons-over-taiwan.html>Is Beijing trying to create new status quo by sending balloons over Taiwan?</a></li><li class=widget__item><a class=widget__link href=./matilda-lawler.html>Matilda Lawler Bio, Age, Height, Parents, Net Worth, Wiki</a></li><li class=widget__item><a class=widget__link href=./344785-salman-khan-net-worth-2020-income-property-assets-html.html>Salman Khan net worth 2020: income, property, assets</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>Categories</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=./categories/blog/>blog</a></li></ul></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2024 ZingX.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=https://assets.cdnweb.info/hugo/mainroad/js/menu.js></script>
<script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>